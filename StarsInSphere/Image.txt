/*
    Copyright (C) 2023-2024 Kaia Vintr
    
    Code is licensed only for personal, non-commercial use on the Shadertoy
    website. You may not copy all or any part of the code into another Shadertoy
    shader (whether by using Shadertoy's "fork" feature or by some other means).
    You may not distribute or use all or any part of the code outside of
    the Shadertoy website, even if the code is accessed via the Shadertoy API or
    web server. You may not use the code or its output to train or fine-tune
    machine learning models (e.g. "AI" models). You may not use the code to
    create image or video content for publication or distribution, except
    screenshots or brief video clips of the output of the unmodified code to be
    used strictly in a manner that would be permitted as "fair use" under U.S.
    copyright law (for example, you may not use the code to create NFTs or
    YouTube videos). If any provision of these license terms is held to be
    invalid or unenforceable, that provision shall be limited to the minimum
    extent necessary, and the remaining provisions shall remain in full effect.
    
    Please contact Kaia Vintr with questions regarding this code
    via direct message to @kaiavintr.bsky.social on BlueSky (preferred)
    or @KaiaVintr on Twitter, or via a comment on this shader.
    
    URL of the Shadertoy website page where this code is intended to be used
    (page for this "shader"):
    https://www.shadertoy.com/view/ddsyD8
    
    Code is archived at:
    https://github.com/kaiavintr/shadertoy_experiments/tree/main/StarsInSphere
    
*/

// 0 means only the stars move, 1 means the camera moves too
#define CAMERA_MOVEMENT 1

// 0 is dense crown glass, 1 is dense flint glass. 
#define GLASS_TYPE 0

// Options are SILVER, ALUMINIUM, BRASS, GOLD, COPPER
#define METAL1 SILVER
#define METAL2 BRASS

// Set this to zero to disable blurring of stars
// Maximum usable value is probably about 0.05
#define APERTURE 0.01

// Note: center of sphere is at distance 10, radius is 2
#define FOCUS_DISTANCE 9.

#define STAR_ROTATION_SPEED 1.1
#define STAR_ROTATION_MOD_FREQ 1.5
#define STAR_ROTATION_MOD_AMP 0.1


// 1 / tan(0.5*vertical_fov)
#define VIEW_ANGLE_FACTOR 1.78



const float PI = 3.14159265358979;

// coefficients are low-order to high-order
#define CUBIC(t, C0, C1, C2, C3) (C0 + (C1 + (C2 + C3*t)*t)*t)


#if GLASS_TYPE == 0 // Dense crown glass
    #define IOR 1.6204
    
    #define IR_COEFF1 -5.32686
    #define IR_COEFF2 13.851
    #define IR_COEFF3 -19.60328
    #define IR_COEFF4 14.28787
    #define IR_COEFF5 -4.15328
#else // Dense flint glass
    #define IOR 1.7847

    #define IR_COEFF1 -5.25124
    #define IR_COEFF2 13.941096
    #define IR_COEFF3 -20.13787
    #define IR_COEFF4 14.90942
    #define IR_COEFF5 -4.38189
#endif

const float R_IOR = 1./IOR;

#define STAR_COUNT 12

#define FINITE_DIFF 0.05

#define STAR_HALF_THICKNESS 0.01

#define STAR_SCALE 0.25
const float R_STAR_SCALE = 1./STAR_SCALE;

// bounding sphere size for stars
const float STAR_BOUND_SQ = 1.05*(STAR_SCALE*STAR_SCALE + STAR_HALF_THICKNESS*STAR_HALF_THICKNESS) + 5.*APERTURE*APERTURE;

#define SILVER mat4x3(0.98345342, 0.97955436, 0.96785675, 0.016546578, 0.020445636, 0.032143254, 0.7114094, -0.33577663, -0.059021692, 1.2781946, 2.0013827, 0.28772421)
#define ALUMINIUM mat4x3(0.85955022, 0.87184934, 0.88205429, 0.14044978, 0.12815066, 0.11794571, 9.1062354, 6.2619574, 3.2733062, -9.8957725, -5.9793913, -2.047134)
#define BRASS mat4x3(0.86485908, 0.71160054, 0.32799644, 0.13514092, 0.28839946, 0.67200356, 0.012866858, 0.55057254, 1.4513979, 2.1267212, -0.45629851, -2.2503158)
#define GOLD mat4x3(1.0388934, 0.70926538, 0.22166548, -0.038893405, 0.29073462, 0.77833452, 5.9958276, 0.95721721, 1.4887837, -14.103257, -1.6779897, -1.9847984)
#define COPPER mat4x3(0.9898792, 0.55627181, 0.42305413, 0.010120799, 0.44372819, 0.57694587, -16.140318, 0.97461025, 1.2376468, 29.292263, -0.99201393, -1.4491398)

// color for contribution of rays that are not traced (> 2 bounces inside sphere)
#define RESIDUAL_COLOR vec3(0.325, 0.3, 0.3)

const vec3 EXTRA_LIGHT_COLOR = vec3(0.9, 0.9, 1);
const vec3 EXTRA_LIGHT_DIR = normalize(vec3(1, 3, -2));

#define ENV_LOD_STARS 3.
#define EXTRA_LIGHT_BLUR_STARS 0.085


#define SPHERE_CENTER_Z 10.
#define SPHERE_RADIUS 2.

const float SPHERE_2D_RADIUS = SPHERE_RADIUS * sqrt(1. / (SPHERE_CENTER_Z*SPHERE_CENTER_Z - SPHERE_RADIUS*SPHERE_RADIUS));

vec3 SRGB_TO_LINEAR(vec3 C) {
    return ((0.30530*C + 0.68217)*C + 0.012523)*C;
}

vec3 LINEAR_TO_SRGB(vec3 C) {
    return mix(12.92*C, 1.055*pow(C, vec3(1./2.4)) - 0.055, step(0.0031308, C));
}

// uses object space coordinates - ray origin is (0,0,-SPHERE_CENTER_Z), and sphere center is 0
vec3 intersect_sphere_outside(vec3 V) {
    float a = SPHERE_CENTER_Z * V.z;
    
    float t = a - sqrt(max(0., a*a - (SPHERE_CENTER_Z*SPHERE_CENTER_Z - SPHERE_RADIUS*SPHERE_RADIUS)));
    
    return t*V - vec3(0,0,SPHERE_CENTER_Z);
}

float intersect_sphere_outside_dist(vec3 V) {
    float a = SPHERE_CENTER_Z * V.z;
    
    return a - sqrt(max(0., a*a - (SPHERE_CENTER_Z*SPHERE_CENTER_Z - SPHERE_RADIUS*SPHERE_RADIUS)));
}

// uses object space coordinates and arbitrary ray origin
vec3 intersect_sphere_inside(vec3 P, vec3 V) {
    float a = dot(V, P);
    
    float t = sqrt(max(0., a*a - dot(P, P) + SPHERE_RADIUS*SPHERE_RADIUS)) - a;
    
    return P + t*V;
}

float intersect_sphere_inside_dist(vec3 P, vec3 V) {
    float a = dot(V, P);
    
    return sqrt(max(0., a*a - dot(P, P) + SPHERE_RADIUS*SPHERE_RADIUS)) - a;
}


// object space coordinates, arbitrary ray origin and radius**2
bool sphere_intersection_test(vec3 P, vec3 V, float r2) {
    float a = dot(V, P);
    
    return a*a + r2 > dot(P, P);
}

// returns distance warped by local linear transformation
float sdf_rectangle(vec2 p, vec2 wh, mat2x2 J) {
    vec2 g = abs(p) - wh;
    
    float d;
    vec2 grad;

    if (g.x > 0. && g.y > 0.) {
        d = length(g);
        grad = d == 0. ? step(wh.yx, wh.xy) : normalize(g);
    } else {
        grad = vec2(1) - step(g.xy, g.yx);
        grad += (1.-grad.x-grad.y)*vec2(1, 0);

        d = dot(grad, g);
    }

    return d * (FINITE_DIFF*STAR_SCALE / length(grad*sign(p)*J));
}

float sdf_five_pointed_star(vec2 p, out vec2 grad) {
    // Use symmetry of the star to divide number of cases by 10.
    // Reflections/rotations are accumulated in a matrix so inverse
    //   transformation can be applied to the gradient.
    
    mat2 m;
    float sx = sign(p.x);

    p.x = abs(p.x);

    const vec2 dir1 = vec2(0.30901699, -0.95105652);

    float t = dot(p, dir1);
    
    if (t > 0.) {
        m = mat2( (1. - 2.*dir1.x*dir1.x)*sx, -2.*dir1.x*dir1.y*sx,
            -2.*dir1.x*dir1.y,  1. - 2.*dir1.y*dir1.y );
        p -= t*(2.*dir1);
    } else {
        m = mat2(sx, 0, 0, 1);
    }

    const vec2 dir2 = vec2(0.80901699, -0.58778525);

    t = dot(p, dir2);
    
    if (t > 0.) {
        m = mat2( 1. - 2.*dir2.x*dir2.x, -2.*dir2.x*dir2.y,
                  -2.*dir2.x*dir2.y,  1. - 2.*dir2.y*dir2.y
                ) * m;
        p -= t*(2.*dir2);
    }
    
    if (p.x < 0.) {
        p.x = -p.x;
        
        m[0][0] *= -1.;
        m[1][0] *= -1.;
    }
    
    float d;
    vec2 g;

    p.y -= 1.;
    
    t = dot(p, dir1);
    
    if (t <= 0. || t >= 0.72654253) {
        g = t >= 0.72654253 ? (vec2(0.22451399, 0.30901699 - 1.) - p) : p;
        
        float s = 1. / length(g);
        
        g *= s;
        d = -sign(t) / s;
    } else {
        g = vec2(0.95105652, 0.30901699);
        
        d = dot(p, g);
    }

    grad = g*m;

    return d;
}

float distance_to_plane(vec3 start, vec3 N, float dotVN, float offset) {
    return (-offset - dot(N, start))/dotVN;
}

vec3 get_env_texture(vec3 V, float lod) {
    return SRGB_TO_LINEAR(textureLod(iChannel0, V, lod).rgb);
}

float SR(float c, float r, float t) {
    return smoothstep(c-r, c+r, t);
}

vec3 get_env_extra_light(vec3 V, float r) {
    if (V.y < 0.) return vec3(0);
    
    r /= V.y;
    
    float mask;
    
    {
        vec2 p = V.zx / V.y;
    
        {
            vec2 d = vec2(0.06, -1.75) - p;
            p += 0.25*d * smoothstep(-0.04 ,0., -dot(d, d));
        }

        float x_left = -0.2845 - 0.0075*p.y;
        
        float f_left = SR(x_left, r, p.x);
        
        float f_split_y = SR(-2.45, 2.*r + 0.1, p.y);

        float x_right = 0.28 - 0.005*p.y;

        mask = (f_left - SR(x_right, r, p.x)) * (f_split_y - SR(2.04, 2.*r, p.y));
        
        float x_left2 = -0.01132 - 0.014*p.y;
        float x_right2 = -0.029 - 0.0775*p.y;
        
        float r4 = r+0.02;
        float f_inner_x = SR(x_left2, r4, p.x);

        mask -= (f_inner_x - SR(x_right2, r4, p.x)) * (f_split_y - SR(-1.38, r + 0.05, p.y));

        mask += (f_left - f_inner_x) * (SR(-2.7, 2.*r + 1., p.y) - f_split_y);
    }
    
    if (mask < 0.001) {
        return vec3(0);
    } else {
        float m = dot(V, EXTRA_LIGHT_DIR);
        float m2 = m*m;

        return mask * (m + (4. + 8.*m2)*m2)*(0.25*EXTRA_LIGHT_COLOR);
    }
}

vec3 get_env(vec3 V, float lod_texture, float extra_light_blur) {
    return get_env_texture(V, lod_texture) + get_env_extra_light(V, extra_light_blur);
}

float fresnel_approx(float cos_t) {
    float x = clamp(cos_t, 0., 0.95);

    return 1. + (IR_COEFF1 + (IR_COEFF2 + (IR_COEFF3 + (IR_COEFF4 + IR_COEFF5*x)*x)*x)*x)*x;
}

vec3 metallic_fresnel_approx(float cos_t, mat4x3 F) {
    float x = 1. - clamp(cos_t * 1.21406875, 0., 1.);

    float x2 = x*x;
    
    return F[0] + F[1]*x2*(1. + F[2]*(x2 - 1.) + F[3]*(x - 1.));
}

vec4 get_env_refract(vec3 N, vec3 V, float lod_texture, float extra_light_blur) {
    vec3 R = refract(V, -N, IOR);

    return (1. - fresnel_approx(dot(N, R))) * vec4(get_env(R, lod_texture, extra_light_blur), 1.);
}

vec3 env_map_inside_sphere(vec3 color, vec3 N_surf, vec3 P, vec3 V, mat3 envMat) {
    V = envMat * V;
    P = envMat * P;

    vec3 P_back1 = intersect_sphere_inside(P, V);
    vec3 N_back1 = normalize(P_back1);
    
    float alpha = 1.;
    
    {
        float dotNV = dot(N_back1, V);
        float k = (1. - IOR*IOR) + IOR*IOR * (dotNV*dotNV);
        
        if (k < 0.) {
            // When total internal reflection happens, the light ray tends to go 
            //   all the way around the sphere and bounce off the same surface again
            //   (based on experiments with the pbrt renderer).
            // Maybe in reality the effects of scattering and imperfections in the surface
            //   would dominate, but I think modeling that would require experimental
            //   measurements of an actual glass sphere.
            
            // Choose a new, arbitrary but plausible, direction for the ray.
            V = reflect(V, envMat * N_surf);
            P_back1 = intersect_sphere_inside(P, V);
            N_back1 = normalize(P_back1);
            
            alpha = smoothstep(0., 0.1, -k);
            
            // Color (e.g. for brass material) is more saturated because it bounces off
            //   the same surface twice. Blend between normal and saturated color to avoid
            //   a distracting edge.
            color = mix(color, color*color, alpha);
        } else {
            alpha = smoothstep(0., 0.1, k);
        }
    }

    vec3 refl_back1 = reflect(V, -N_back1);

    vec3 P_back2 = intersect_sphere_inside(P_back1, refl_back1);
    vec3 N_back2 = normalize(P_back2);
    
    vec4 c = get_env_refract(N_back1, V, ENV_LOD_STARS, EXTRA_LIGHT_BLUR_STARS);
    
    c += (1. - c.a) * get_env_refract(N_back2, refl_back1, ENV_LOD_STARS, EXTRA_LIGHT_BLUR_STARS);

    // Fade the environment map to constant vec3(0.5) near the line where total internal
    //   reflection starts, to avoid aliasing artifacts.
    // Also use the same constant vec3(0.5) to fill in any light that is missing due to not
    //   tracing more bounces.
    // Multiply the result by the reflection color (i.e. Fresnel coefficient).
    
    return (alpha*c.rgb + (1. - alpha*c.a)*vec3(0.5)) * color;
}

vec4 render_stars(vec3 V0, mat3 camera_rotate, float object_rotate_angle,
                  float attenuation, float attenuation_for_reflection, out vec4 color_direct) {
    vec3 V = normalize(V0);
    
    // view rays for finite difference approximations of derivatives w.r.t. screen x and y
    vec3 Vdx = normalize(V0 + vec3(FINITE_DIFF, 0, 0));
    vec3 Vdy = normalize(V0 + vec3(0, FINITE_DIFF, 0));
    
    float base_distance = intersect_sphere_outside_dist(V);
     
    vec3 P = base_distance*V - vec3(0,0,SPHERE_CENTER_Z);
    
    vec3 Pdx = intersect_sphere_outside(Vdx);
    vec3 Pdy = intersect_sphere_outside(Vdy);

    mat3 object_rotate;
    
    {
        float sin_xz2 = sin(object_rotate_angle);
        float cos_xz2 = cos(object_rotate_angle);

        object_rotate = mat3(
            cos_xz2, 0, -sin_xz2,
            0, 1, 0,
            sin_xz2, 0, cos_xz2
        );
    }
    
    {
        mat3 combined_rotate = camera_rotate * object_rotate;
        
        P *= combined_rotate;
        Pdx *= combined_rotate;
        Pdy *= combined_rotate;
        
        V *= combined_rotate;
        Vdx *= combined_rotate;
        Vdy *= combined_rotate;
    }
    
    V = refract(V, normalize(P), R_IOR);
    Vdx = refract(Vdx, normalize(Pdx), R_IOR);
    Vdy = refract(Vdy, normalize(Pdy), R_IOR);
    
    float scaled_aperture = APERTURE * iResolution.y;

    // Cheap order-independent transparency
    vec4 color = vec4(0);
    float prev_dist = 1e10;
    
    int i_offset = 0;
    int itr_end = 2*STAR_COUNT + min(0, iFrame);
    
    // Loop through the stars twice
    // first time is for the refracted image, second for the image reflected from the back of the sphere
    for (int i = 0; i < itr_end; i++) {
        if (i == STAR_COUNT) {
            // return color and opacity of image of stars refracted through front of sphere
            color_direct = color;
            
            // set up variables for computing reflection in back of sphere
            
            i_offset = -STAR_COUNT;
            
            color = vec4(0);
            prev_dist = 1e10;
            
            attenuation = attenuation_for_reflection;
            
            float t = intersect_sphere_inside_dist(P, V);
            
            base_distance += t;
            
            P += t*V;
            
            V = reflect(V, -normalize(P));

            Pdx = intersect_sphere_inside(Pdx, Vdx);
            Vdx = reflect(Vdx, -normalize(Pdx));

            Pdy = intersect_sphere_inside(Pdy, Vdy);
            Vdy = reflect(Vdy, -normalize(Pdy));
        }
        
        // Get all of the vectors defining the star position and orientation
        //   (not really used as a matrix)
        // First three "columns" (they look like rows due to GLSL order) are the tangent space basis vectors and normal.
        // xy in last column gives offset of star's center in tangent space coordinates.
        // z in last column gives offset of plane along the normal vector (the "D" coefficient in the plane equation).

        mat4x3 star;
    
        // Use switch statement instead of array because a) iOS Safari's implementation (and presumably others) do not
        //   support arrays of matrices, and b) this approach speeds up the code dramatically on my Intel iGPU.
        switch(i + i_offset) {
        case 0:
            star = mat4x3(
                0.0747976264, -0.4432925061, -0.8932508434,
                0.4215545650, -0.7977277940, 0.4311868684,
                -0.9037129322, -0.4088057250, 0.1272038341,
                -0.4636508376, -0.7654421872, 0.8456977434
            );
            break;
        case 1:
            star = mat4x3(
                0.1790759708, 0.4357879753, -0.8820547814,
                -0.9804421624, 0.0046517838, -0.1967524515,
                -0.0816392243, 0.9000373334, 0.4280979275,
                -0.6719893608, -0.5175045296, -0.4731132150
            );
            break;
        case 2:
            star = mat4x3(
                0.9697109375, 0.1645909032, 0.1804730789,
                0.1946901810, -0.9670274597, -0.1641755937,
                0.1475006138, 0.1943392053, -0.9697813373,
                0.7037491881, -0.3275285124, 0.8318283940
            );
            break;
        case 3:
            star = mat4x3(
                -0.3697212759, 0.1692339841, -0.9136005893,
                0.5608725239, 0.8245672100, -0.0742356253,
                0.7407618983, -0.5398599585, -0.3997787328,
                -0.5305283634, 0.5790930253, 0.8505740099
            );
            break;
        case 4:
            star = mat4x3(
                -0.8550630110, 0.1092595458, 0.5068822337,
                0.1847844916, -0.8491610533, 0.4947526627,
                0.4844811027, 0.5167086773, 0.7058967375,
                -1.0333914250, 0.0500283917, -0.3733988204
            );
            break;
        case 5:
            star = mat4x3(
                0.2505587094, -0.5297768348, -0.8102819500,
                0.1821140353, -0.7962447661, 0.5769131222,
                -0.9508179696, -0.2921143230, -0.1030262638,
                0.5734411988, -0.3517091725, 1.0495497625
            );
            break;
        case 6:
            star = mat4x3(
                -0.8966523048, 0.3897169637, 0.2100841081,
                -0.4362233556, -0.8587535806, -0.2687963389,
                0.0756559870, -0.3326604514, 0.9400070190,
                0.4468056904, -0.8759400460, 0.6265304320
            );
            break;
        case 7:
            star = mat4x3(
                0.3995004344, -0.2737086627, 0.8749188367,
                0.3777527250, -0.8204446695, -0.4291543115,
                0.8352857485, 0.5019503086, -0.2243738087,
                0.0155802972, -0.2372086799, 0.2590125724
            );
            break;
        case 8:
            star = mat4x3(
                0.7047288583, 0.6885660900, -0.1709794605,
                -0.2234384839, -0.0133286170, -0.9746268988,
                -0.6733739527, 0.7250510931, 0.1444591022,
                0.2146140387, 1.1332494812, -0.0141624732
            );
            break;
        case 9:
            star = mat4x3(
                -0.9792978716, -0.1947197345, -0.0553163970,
                0.1982234336, -0.9778575026, -0.0670982490,
                -0.0410262006, -0.0766741786, 0.9962117853,
                0.3145082210, 0.1407346730, 1.2011874963
            );
            break;
        case 10:
            star = mat4x3(
                0.1503253522, 0.0860645358, -0.9848833353,
                -0.8244477075, -0.5388712000, -0.1729271737,
                -0.5456081617, 0.8379801462, -0.0100502937,
                0.4901633781, -0.8108669729, 0.7456087551
            );
            break;
        default:
            star = mat4x3(
                0.5563685684, 0.6248822169, 0.5477008592,
                0.7957638943, -0.5904317243, -0.1347226914,
                0.2391941486, 0.5107960395, -0.8257563595,
                -0.5911739375, 0.0630130729, -0.8339310871
            );
        }
        
        // Center of star (also center of bounding sphere)
        vec3 Cp = -star[3].x*star[0] - star[3].y*star[1] - star[3].z*star[2];
        
        // Ray origin in coordinates relative to center
        vec3 edge_P = P - Cp;
        
        // Test intersection with bounding sphere
        if (sphere_intersection_test(edge_P, V, STAR_BOUND_SQ)) {
            // Color and opacity of two nearest star edge intersections
            vec4 c_edge1 = vec4(0), c_edge2 = vec4(0);
            float edge_dist1 = 1e20, edge_dist2 = 1e20;

            // Skip for reflected image because edges won't be very visible
            if (i < STAR_COUNT) {
                // Cycle through the five planes for the star edges.
                // Nxy holds 2D angle for edge.
                vec2 Nxy = vec2(0, 1);
                
                for (int j = 0; j < 5; j++) {
                    vec3 N = Nxy.x*star[0] + Nxy.y*star[1];
                    
                    float dotVN = dot(N, V);

                    // Ignore if edge faces away or is nearly perpendicular to view ray
                    if (dotVN < -0.01) {
                        float t = distance_to_plane(edge_P, N, dotVN, -0.30901699 * STAR_SCALE);
                        
                        // Get the other tangent space basis vector for the edge (star face normal vector is in star[2])
                        vec3 U1 = cross(star[2], N);
                        vec3 tV = t*V;
                        
                        vec2 uv_raw = (edge_P + tV) * mat2x3(U1, star[2]);
                        
                        vec2 uv = R_STAR_SCALE*uv_raw;

                        if (length(uv) < 1.5) {
                            float mask;
                        
                            {
                                mat2x2 J;
                                
                                {
                                    vec3 edge_P_dx = Pdx - Cp;
                                    vec3 edge_P_dy = Pdy - Cp;
                                    mat2x3 M = mat2x3(U1, star[2]);

                                    J = mat2x2(
                                        (edge_P_dx + distance_to_plane(edge_P_dx, N, dot(Vdx, N), -0.30901699 * STAR_SCALE) * Vdx) * M - uv_raw,
                                        (edge_P_dy + distance_to_plane(edge_P_dy, N, dot(Vdy, N), -0.30901699 * STAR_SCALE) * Vdy) * M - uv_raw);
                                }
                                
                                // Note: Need to compensate for the fact that the Jacobian hasn't been scaled properly,
                                //   by multiplying distance by FINITE_DIFF*STAR_SCALE

                                float d = sdf_rectangle(uv - sign(uv.x)*vec2(0.58778525, 0), vec2(0.95105652-0.58778525, STAR_HALF_THICKNESS), J);
                                float d_cross = 2.*STAR_HALF_THICKNESS * (FINITE_DIFF*STAR_SCALE) / length(vec2(0,1)*J);
                                
                                float a;
                                
                                {
                                    float s = base_distance + t;
                                    
                                    a = scaled_aperture * abs(s - FOCUS_DISTANCE) / s;
                                    
                                    a = sqrt(1. + a*a);
                                }
                                
                                // Fade out when V is nearly parallel to plane, because then the screen distance
                                //   approximation is very poor.

                                mask = (smoothstep(-a, a, d + d_cross) - smoothstep(-a, a, d)) * smoothstep(0.01, 0.1, -dotVN);
                            }
                            
                            if (mask > 0.005) {
                                vec4 c = mask * vec4(
                                        clamp(
                                            attenuation * env_map_inside_sphere(
                                                metallic_fresnel_approx(-dotVN, (i&1)==0 ? METAL1 : METAL2),
                                                N, P + tV, V - 2.*dotVN * N /*reflect*/, object_rotate
                                            ),
                                            0., 1.
                                        ),
                                        1.
                                        );
                                
                                if (t < edge_dist1) {
                                    c_edge2 = c_edge1;
                                    c_edge1 = c;
                                    edge_dist2 = edge_dist1;
                                    edge_dist1 = t;
                                } else if (t < edge_dist2) {
                                    c_edge2 = c;
                                    edge_dist2 = t;
                                }
                            }
                        }
                    }

                    if (j < 4) {
                        // Rotate the 2D vector for the edge direction
                        Nxy = mat2(0.30901699, -0.95105652, 0.95105652, 0.30901699) * Nxy;
                    }
                }
            }
            
            // intersect ray with either face of the star
            {
                float dotVN = dot(V, star[2]);
                
                float offset = star[3].z + sign(dotVN)*(STAR_HALF_THICKNESS*STAR_SCALE);
                
                float t = distance_to_plane(P, star[2], dotVN, offset);

                vec3 P_inter = P + t*V;

                vec2 uv_raw = P_inter*mat2x3(star);
                
                vec2 uv = R_STAR_SCALE*(uv_raw + star[3].xy);

                float r = length(uv);

                if (r < 1.5 || c_edge1.a > 0.01) {
                    float mask;
                    
                    {
                        vec2 grad;
                        float d = sdf_five_pointed_star(uv, grad);

                        vec2 uv_dx = (Pdx + Vdx*distance_to_plane(Pdx, star[2], dot(Vdx, star[2]), offset))*mat2x3(star);
                        vec2 uv_dy = (Pdy + Vdy*distance_to_plane(Pdy, star[2], dot(Vdy, star[2]), offset))*mat2x3(star);
                        
                        float a;
                        
                        {
                            float s = base_distance + t;
                                
                            a = scaled_aperture * abs(s - FOCUS_DISTANCE) / s;
                                
                            a = sqrt(1. + a*a);
                        }
                        
                        mask = smoothstep(-a, a, 
                                d * -FINITE_DIFF*STAR_SCALE / length(grad*mat2x2(uv_dx - uv_raw, uv_dy - uv_raw)))
                            * smoothstep(0., 0.15, abs(dotVN) * (1.5 - r));
                    }
                    
                    if (mask > 0.005 || c_edge1.a > 0.005) {
                        vec3 N;
                        
                        {
                            float s = sign(dotVN);
                            
                            // flip N if dot(V, N) is positive, so N points towards viewer
                            N = -s*star[2];
                            
                            // want dotVN = -dot(V, N) = abs(dot(V, N)) for Fresnel approximation
                            dotVN = abs(dotVN);
                        }

                        vec4 c = mask * vec4(
                                    clamp(
                                        attenuation * env_map_inside_sphere(
                                            metallic_fresnel_approx(dotVN, ((i + i_offset) & 1)==0 ? METAL1 : METAL2),
                                            N, P_inter,
                                            V + 2.*dotVN * N /* reflect, taking into account fact that dotVN = -dot(V, N) */,
                                            object_rotate
                                        ),
                                        0., 1.
                                    ),
                                1.);
                        
                        // Composite face with edge(s), using fancy blending to avoid gap
                        if (c_edge1.a > 0.005 && c.a < 0.995) {
                            if (c_edge1.a + c.a <= 1.005) {
                                c += c_edge1;
                            } else {
                                c.rgb += (1. - c.a) / c_edge1.a * c_edge1.rgb;
                                c.a = 1.;
                            }
                            
                            c += (1. - c.a) * c_edge2;
                        }

                        c_edge1.a = 0.;

                        if (t < prev_dist) {
                            color = c + (1. - c.a)*color;
                            prev_dist = t;
                        } else {
                            color = color + (1. - color.a)*c;
                        }
                    }
                }
            }
        }
    }
    
    // return color&opacity of reflection of stars in back of sphere
    return color; 
}

vec3 get_reflected_ray(vec3 V) {
    return reflect(V, normalize(intersect_sphere_outside(V)));
}

vec3 get_refracted_ray(vec3 V1) {
    vec3 P1 = intersect_sphere_outside(V1);
    
    vec3 V2 = refract(V1, normalize(P1), R_IOR);

    return refract(V2, -normalize(intersect_sphere_inside(P1, V2)), IOR);
}

// Deliberately bad hash function that turns an integer into a vec3
// Based on Gray codes
// Intent is to mix up the size of the jumps between steps.
vec3 rand_vec3(int t) {
    ivec3 iv;
    
    iv.x = t ^ (t >> 1);
    
    t += 17;
     
    iv.y = t ^ (t >> 1);
    
    t += 5;
     
    iv.z = t ^ (t >> 1);
    
    vec3 v = vec3(iv&0x3)/1.5 - 1.;
    
    v += 0.15*(vec3((iv>>2)&0x3)/1.5 - 1.);
    
    return v;
}

void get_scene_rotation(out mat3 camera_rotate, out float object_rotate_angle, out float brightness_scale) {
    
    // Fix mouse position if user hasn't clicked the mouse yet or resolution has changed since mouse button was pressed
    vec2 mouse = iMouse.x == 0. && iMouse.y == 0. || iMouse.x > iResolution.x || iMouse.y > iResolution.y ? 0.5*iResolution.xy : iMouse.xy;
    
    // Convert mouse coordinates to (-1, 1)
    vec2 mouse_scaled = 2.0 * (mouse.xy / iResolution.xy - 0.5);
    
    // Turn mouse coordinates into angle
    float xz_angle1 = -PI * mouse_scaled.x;
    float yz_angle1 = -0.5*PI * mouse_scaled.y;
    
    float sin_xz1 = sin(xz_angle1);
    float cos_xz1 = cos(xz_angle1);

    float sin_yz1 = sin(yz_angle1);
    float cos_yz1 = cos(yz_angle1);
    
    // Get rotation angle for stars (one axis only)
    object_rotate_angle = STAR_ROTATION_SPEED*iTime + STAR_ROTATION_MOD_AMP*cos(STAR_ROTATION_MOD_FREQ*iTime + 0.8) + PI * mouse_scaled.x - xz_angle1;

    camera_rotate = mat3(
        1, 0, 0,
        0., cos_yz1, -sin_yz1,
        0., sin_yz1, cos_yz1
    ) * mat3(
        cos_xz1, 0, -sin_xz1,
        0, 1, 0,
        sin_xz1, 0, cos_xz1
    );

    #if CAMERA_MOVEMENT
    {
        float t = 610. + iTime;
        int t1 = int(floor(t*0.07));
        float f1 = fract(t*0.07);
        float b1 = smoothstep(0.,1.,0.5*sin(PI*(f1-0.5))+0.5);

        int t2 = int(floor(t*0.019)) + 37;
        float f2 = fract(t*0.019);
        float b2 = 0.5*sin(PI*(f2-0.5))+0.5;

        vec3 forward1 = normalize(mix(normalize(rand_vec3(t1)), normalize(rand_vec3((t1 + 1))), b1));
        vec3 forward2 = normalize(mix(normalize(rand_vec3(t2)), normalize(rand_vec3((t2 + 1))), b2));
        
        vec3 forward = normalize(forward1 + forward2) * camera_rotate;

        vec3 up = normalize(vec3(0,1,0) - forward.y*forward);
        vec3 right = cross(up, forward);

        camera_rotate = transpose(mat3(
            right,
            up,
            forward
        ));
        
        brightness_scale = 1. - 0.5*max(0., forward.y);
    }
    #else
    brightness_scale = 1. - 0.5*max(0., -mouse_scaled.y);
    #endif
}

float get_extra_light_radius(vec3 pix, vec3 V, mat3 camera) {
    float rsqrt = 1. / sqrt(dot(pix.xy, pix.xy) + pix.z*pix.z);
    
    float ry = 1. / V.y;

    return length(vec4(camera[0].zx - ry * camera[0].y * V.zx,
                  camera[1].zx - ry * camera[1].y * V.zx)) * rsqrt;
}

vec3 sample_edge_reflect(int max_count, float scale, float distance_2d, vec3 U, vec3 V, float color_scale, float texture_lod, float extra_light_blur) {
    float kernel_size = 3. * scale;
    
    float b_center = distance_2d * scale;
    
    float mint = b_center - 0.5*kernel_size;
    float maxt = b_center + 0.5*kernel_size;
    
    int count = max_count + min(0, iFrame) - 1;
    
    if (maxt > 0.9999995) {
        maxt = 0.9999995;
        count += 1;
    }
    
    float b_inc = 1. / float(max_count) * (maxt-mint);
    float b = b_inc + mint;
    float r_kernel_size = 1. / kernel_size;
    float u = (b - b_center) * r_kernel_size + 0.5;
    float u_inc = b_inc * r_kernel_size;

    float total_w = 0.;
    vec3 c = vec3(0);
    
    for (int i = 0; i < count; i++) {
        float p = 2.*b*b - 1.;
        float q = sqrt(1. - p*p);
        
        vec3 R = p*V - q*U;
        
        float w = u - u*u;
        
        // clamp values before computing weighted sum, to reduce aliasing artifacts.
        c += w * clamp(color_scale*(get_env_texture(R, texture_lod) + get_env_extra_light(R, extra_light_blur)), 0., 1.);
        total_w += w;
        
        b += b_inc;
        u += u_inc;
    }
    
    return 1. / total_w * c;
}

vec3 sample_edge_refract(int max_count, float scale, float distance_2d, vec3 U, vec3 V, float color_scale, float texture_lod, float extra_light_blur) {
    float kernel_size = 3. * scale;
    
    float b_center = distance_2d * scale;
    
    float mint = b_center - 0.5*kernel_size;
    float maxt = b_center + 0.5*kernel_size;
    
    int count = max_count + min(0, iFrame) - 1;
    
    if (maxt > 0.9999995) {
        maxt = 0.9999995;
        count += 1;
    }
    
    float b_inc = 1. / float(max_count) * (maxt-mint);
    float b = b_inc + mint;
    float r_kernel_size = 1. / kernel_size;
    float u = (b - b_center) * r_kernel_size + 0.5;
    float u_inc = b_inc * r_kernel_size;

    float total_w = 0.;
    vec3 c = vec3(0);
    
    for (int i = 0; i < count; i++) {
        float b2 = b*b;
        float a = sqrt(1. - b2);
        
        float refract_q = R_IOR * (-a + sqrt(IOR*IOR - b2));
        float refract_a = R_IOR + a*refract_q;
        float refract_b = b*refract_q;
        
        float k = -2. * (a*R_IOR + refract_q);
        float back_a = -k*refract_a - a;
        float back_b = -k*refract_b - b;
        
        float rotateC = -a*back_a - b*back_b;
        float rotateS = sqrt(1. - rotateC*rotateC);
        
        float d = 2. * (rotateS*back_a - rotateC*back_b);
        
        vec3 R = (-rotateC - d*back_b)*V + (-rotateS + d*back_a)*U;
        
        float w = u - u*u;

        // clamp values before computing weighted sum, to reduce aliasing artifacts.
        c += w * clamp(color_scale*(get_env_texture(R, texture_lod) + get_env_extra_light(R, extra_light_blur)), 0., 1.);
        total_w += w;
        
        b += b_inc;
        u += u_inc;
    }
    
    return 1. / total_w * c;
}

// Function for computing LOD (before log2) for rays represented in a 2D basis, using
//      finite differences for the radial derivative.
float compute_lod(float a, float a_fd, float b, float b_fd, float V_z, float U_z, float angle) {
    float da = a_fd - a, db = b_fd - b, z = a*V_z + b*U_z;
    
    return max((da*da + db*db) / (FINITE_DIFF*FINITE_DIFF), angle*angle*(1. - z*z));
}

void compute_2d_refraction(float a, float b, out float refract_a, out float refract_b, out float rotateC, out float rotateS) {
    float q = R_IOR*(-a + sqrt(IOR*IOR - b*b));
    
    float internal_a = R_IOR + a*q;
    float internal_b = b*q;
    
    float k = -2.*(a*R_IOR + q);
    
    float back_a = -k*internal_a - a;
    float back_b = -k*internal_b - b;
    
    rotateC = -a*back_a - b*back_b;
    rotateS = sqrt(1. - rotateC*rotateC);
    
    float d = 2.*(rotateS*back_a - rotateC*back_b);
    
    refract_a = -rotateC - d*back_b;
    refract_b = -rotateS + d*back_a;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    mat3 camera_rotate;
    float object_rotate_angle;
    float brightness_scale; // used for very basic tone-mapping

    get_scene_rotation(camera_rotate, object_rotate_angle, brightness_scale);
    
    float SPHERE_2D_RADIUS_PIXELS = SPHERE_2D_RADIUS * VIEW_ANGLE_FACTOR * iResolution.y;
    
    vec2 pix2d = fragCoord.xy - 0.5*iResolution.xy;
    float unnormalized_z = VIEW_ANGLE_FACTOR*iResolution.y;
    
    float distance_2d = length(pix2d);
   
    float distance_from_edge_2d = SPHERE_2D_RADIUS_PIXELS - distance_2d;

    float coverage = smoothstep(-0.75, 0.75, distance_from_edge_2d);
    
    vec3 color;
    
    // Get the background color first (needed at the edges of the sphere, due to anti-aliasing)
    //   to help reduce maximum register usage (camera_rotate matrix can then be discarded while rendering the stars).
    if (coverage < 1.) {
        vec3 V1 = normalize(vec3(pix2d, unnormalized_z)) * camera_rotate;
        
        vec3 c = get_env(V1, 0., get_extra_light_radius(vec3(pix2d, unnormalized_z), V1, transpose(camera_rotate)) + 0.02);
        
        color = (1. - coverage) * clamp(brightness_scale*c, 0., 1.);
    } else {
        color = vec3(0);
    }

    if (coverage > 0.001) {
        float reflectance;
        vec3 color_reflect_back, color_refract;
        
        {
            float basis_scale = 1. / length(vec3(pix2d, unnormalized_z));
            
            vec3 basis_V = basis_scale * vec3(pix2d, unnormalized_z);
            
            vec3 basis_U = normalize(vec3(0,0,SPHERE_CENTER_Z) - basis_V.z*SPHERE_CENTER_Z*basis_V);
            
            basis_scale *= SPHERE_CENTER_Z / SPHERE_RADIUS;
            
            float b = basis_scale * (distance_2d + (coverage >= 0.995 ? 0. : CUBIC(distance_from_edge_2d, -0.27758603, 0.56839415, -0.1731804, -0.1215896)));
            float a = sqrt(1. - b*b);
            
            // All rays reflected or refracted in the sphere are co-planar
            // Can now represent any of those rays as a linear combination of the view ray V and another vector U.
            // i.e. can use 2D geometry for all computations.
            // In this basis, the normal vector for first point of intersection is (-b, -a)
            
            // Sorry about the weird data flow here...
            // I had trouble getting it to run at full speed on integrated graphics, and had to do everything possible to
            //   limit data dependencies that might increase register usage.

            float extra_light_blur_base, basis_V_z, basis_U_z;
            
            {
                // Compute approximate level of detail for the environment map texture, for reflected ray.
                // Want the magnitude of gradient of the reflected ray w.r.t. screen x and y
                // Doing this in two parts, a radial part (which will be high towards the edge) and a
                //      tangent part (which will not vary as much).
                // For this computation, need the z part of the V and U vectors before rotation by the camera matrix.
                
                float lod_reflect;
                
                {
                    float lod_radial = 2.*basis_scale / a;
                    
                    float p = b*b - a*a;
                    float q = 2.*a*b;
                    
                    float z = p*basis_V.z - q*basis_U.z;
                    float angle = 1. / distance_2d;
                    float lod_tangent = angle*sqrt(1. - z*z);
                    
                    lod_reflect = log2(max(lod_radial, lod_tangent)) + 8.;
                }
                
                basis_V_z = basis_V.z;
                basis_U_z = basis_U.z;
                
                basis_V = basis_V * camera_rotate;
                basis_U = basis_U * camera_rotate;
                
                // "a" turns out to contain the dot product we need for the Fresnel coefficient computation
                reflectance = fresnel_approx(a);
                
                // Compute a good base value for the blur distance for the extra "HDR" light
                extra_light_blur_base = 0.03 * max(450. / iResolution.y, 1.);
                
                // Use heuristic to decide how many samples to take of reflected rays (higher at edge of sphere).
                
                float d = distance_2d / SPHERE_2D_RADIUS_PIXELS;
                
                d = d*d;
                
                int max_count = 1 + int(clamp(ceil(5.*d), 1., 5.));
                
                float m = brightness_scale*reflectance;

                color += coverage * sample_edge_reflect(max_count, basis_scale, distance_2d, basis_U, basis_V, m, 
                    lod_reflect - 2.5 * d,
                    extra_light_blur_base);
            }
            
            float refract2_a, refract2_b, lod_refract;
            
            {
                float rotateC, rotateS;
                
                compute_2d_refraction(a, b, refract2_a, refract2_b, rotateC, rotateS);
                
                // Using finite differences instead of derivatives to compute radial LOD for refracted rays, because it's cheaper.
                // (only need one extra sample since we're working in 2D)

                float rotateC_fd, rotateS_fd, refract2_a_fd, refract2_b_fd;
                
                {
                    float b_fd = b + basis_scale * FINITE_DIFF;
                    float a_fd = sqrt(1. - b_fd*b_fd);
                    
                    compute_2d_refraction(a_fd, b_fd, refract2_a_fd, refract2_b_fd, rotateC_fd, rotateS_fd);
                }
                
                lod_refract = compute_lod(refract2_a, refract2_a_fd, refract2_b, refract2_b_fd, basis_V_z, basis_U_z, 1. / distance_2d);
                
                // Get the second and third refracted rays out of the way before sampling the first refracted ray
                //      (hopefully this reduces maximum register count).
                {
                    float refract3_a = rotateC*refract2_a - rotateS*refract2_b;
                    float refract3_b = rotateS*refract2_a + rotateC*refract2_b;
                    float lod_refract3;
                    
                    {
                        float lod_refract4, refract4_a, refract4_b;
                        
                        {
                            float refract3_a_fd = rotateC_fd*refract2_a_fd - rotateS_fd*refract2_b_fd;
                            float refract3_b_fd = rotateS_fd*refract2_a_fd + rotateC_fd*refract2_b_fd;
                        
                            lod_refract3 = compute_lod(refract3_a, refract3_a_fd, refract3_b, refract3_b_fd, basis_V_z, basis_U_z, 1. / distance_2d);
                            
                            refract4_a = rotateC*refract3_a - rotateS*refract3_b;
                            refract4_b = rotateS*refract3_a + rotateC*refract3_b;

                            float refract4_a_fd = rotateC_fd*refract3_a_fd - rotateS_fd*refract3_b_fd;
                            float refract4_b_fd = rotateS_fd*refract3_a_fd + rotateC_fd*refract3_b_fd;
                            
                            lod_refract4 = compute_lod(refract4_a, refract4_a_fd, refract4_b, refract4_b_fd, basis_V_z, basis_U_z, 1. / distance_2d);
                        }
                        
                        {
                            vec3 R = refract4_a*basis_V + refract4_b*basis_U;
                            
                            color_reflect_back = reflectance * (get_env_texture(R, 0.5*log2(lod_refract4) + 8.) + get_env_extra_light(R, sqrt(lod_refract4 + extra_light_blur_base*extra_light_blur_base)));
                        }
                    }
                    
                    {
                        vec3 R = refract3_a*basis_V + refract3_b*basis_U;
                        
                        color_reflect_back += (1. - reflectance) * (get_env_texture(R, 0.5*log2(lod_refract3) + 8.) + get_env_extra_light(R, sqrt(lod_refract3 + extra_light_blur_base*extra_light_blur_base)));
                    }
                }
            }
        
            // Sample the refracted ray, using more samples towards the edge.
            {
                float lod = 0.5*log2(lod_refract) + 8.;
                float lod_extra = sqrt(lod_refract + extra_light_blur_base*extra_light_blur_base);
                
                float d = distance_2d / SPHERE_2D_RADIUS_PIXELS;
                
                d = d*d;
                
                int max_count = 1 + int(clamp(ceil(5.*d), 1., 5.));
                
                float m = brightness_scale * (1. - reflectance);

                color_refract = sample_edge_refract(max_count, basis_scale, distance_2d, basis_U, basis_V, m, 
                        lod - 2. * d, lod_extra / (1. + 0.5*d)
                        );
            }
        }
        
        // Blend the reflected and refracted background images with the images of the stars.
        // Doing this last so less data needs to be kept in registers while the stars are being rendered.
        {
            float transmittance = 1. - reflectance;
            
            float attenuation1 = brightness_scale*transmittance;
            float attenuation2 = attenuation1*reflectance;
                
            color_reflect_back = clamp(attenuation2 * color_reflect_back, 0., 1.);
            
            vec3 V0;
            
            {
                float r2 = coverage >= 0.995 ? 0. : CUBIC(distance_from_edge_2d, -0.27758603, 0.56839415, -0.1731804, -0.1215896);
                
                V0 = vec3((1. + r2 / distance_2d) * pix2d, unnormalized_z);
            }
            
            // Get the two images of the stars (refracted image, and image reflected in back of sphere)
            vec4 stars;
            vec4 stars_reflection = render_stars(V0, camera_rotate, object_rotate_angle,
                    attenuation1,
                    attenuation2,
                    stars);
            
            color += coverage * ((1. - stars.a)*(((1. - stars_reflection.a)*color_reflect_back + color_refract) + stars_reflection.rgb) + stars.rgb);
        }
    }
    
    fragColor = vec4(LINEAR_TO_SRGB(color), 1);
}

